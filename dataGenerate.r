# Author: Dongliang Zhang (^)
#
# Advisors:    Professor Masoud Asgharian (*)
#              Professor Martin Lindquist (^) 
#              Professpr Mei-Cheng Wang (^)
#
# Current Affiliation: (*) Department of Mathematics and Statistics, McGill University, Montreal, Quebec, Canada  
#                      (^) Department of Biostatistics, Johns Hopkins University, Baltimore, Maryland, USA  
#
# Title of Project: Detection of Influential Observations on Variable Selection 
#
# R Script Purpose: to generate (1) design matrix X 
#                               (2) perturbed versions of design matrix X and response vector Y   
#
# Created on :  August 2, 2018
# Modified on:  September 29, 2021
#               September 30, 2021
#               October 2, 2021
#               March 23, 2022 
#               March 27, 2022 
#               March 30, 2022
#               April 24, 2022 
#               May 10, 2022 
#               May 04, 2023 
#
# Verified on:  September 30, 2021 

#######################################################################################################################################
# Function: ARcov(rho,n)  
#
# Purpose of Function: to generate AR-type variance-covariance matrix 
#
# Args:
#   rho :  pairwise correlation 
#   p   :  number of covariates 
#
# Returns:
#   AR-type variance-covariance matrix with dimension p by p;               

ARcov <- function(rho,p) {
  covM <- matrix(1:p*p, nrow=p,ncol=p)
  for(i in 1:p) {
    for(j in 1:p) {
      covM[i,j]=  rho^abs(i-j)
    }
  }
  return(covM);
}


#######################################################################################################################################
# Function: equicov(rho,p) 
#
# Purpose of Function: to generate equi-correlation typer variance-covariance matrix 
#
# Args:
#   rho :  common pairwise correlation 
#   p   :  number of covariates
#
# Returns:
#   Equicorrelation variance-covariance matrix with dimension p by p;              
#

equicov <- function(covX, p, varX) {
  covM <- matrix(covX, nrow=p, ncol=p); 
  diag(covM) <- varX; 
  return(covM);
}


#######################################################################################################################################
# Function: X.generator 
#
# Args:
#   n        :  number of observations
#   p        :  number of covariates
#   family   :  a string indicating the type of design matrix: (1) "eq" is for equi-correlated; 
#                                                              (2) "tp" is for Toeplitz-type;
#                                                              (3) "expo" is for exponential decay;  
#                                                              (4) "iid" is for independent case; 
#   rho.equi :  pair-wise correlation coefficient used in generating equi-correlated design matrix  
#   rho.ar   :  pair-wise correlation coefficient used in generating Toeplitz-type design matrix  
#
# Returns: 
#   X        :  design matrix generated by multivariate normal distribution with specific variance-covariance structure 
#

X.generator <- function(n, p, family=c("eq","tp","expo","iid"), rho.equi, rho.ar){
  
  family <- match.arg(family);
  
  if(family=="iid"){
    X <- rmvnorm(n, mean = rep(1, p), sigma = diag(p))
    colnames(X) <- colnames(X, do.NULL = FALSE, prefix = "x")
    #X <- scale(X);
    #print("Hello")
  }
  
  if(family=="eq"){
    X.sigma <- equicov(rho.equi,p,1);
    X <- rmvnorm(n, mean=rep(1, p), X.sigma, method=c("eigen", "svd", "chol"));
    colnames(X) <- colnames(X, do.NULL = FALSE, prefix = "x")
    #X <- scale(X);
  }
  
  if(family=="tp"){
    X.sigma <- ARcov(rho.ar,p);
    X <- rmvnorm(n, mean=rep(0,p), X.sigma, method=c("eigen", "svd", "chol"));
    colnames(X) <- colnames(X, do.NULL = FALSE, prefix = "x")
    #X <- scale(X);
  }
  
  if(family=="expo"){
    covM <- matrix(1:p*p, nrow=p,ncol=p)
    
    for(i in 1:p) {
      for(j in 1:p) {
        covM[i,j]=  0.5^abs(i-j)/5;
      }
    }
    
    X.sigma <- ginv(covM); 
    X <- rmvnorm(n, mean=rep(0,p), X.sigma, method=c("eigen", "svd", "chol"));
    colnames(X) <- colnames(X, do.NULL = FALSE, prefix = "x")
    #X <- scale(X);
  }
  
  return (X); 
}


#######################################################################################################################################
# Function: data.perturb 
#
# Purpose of Function: to generate design matrix X under perturbation; 
#
# Reference: 1. High-dimensional influence measure, 
#               Author(s): Junlong Zhao, Chenlei Leng, Lexin Li, and Hansheng Wang; 
#               Journal: Annuals of Statistics, Volume 41, Number 5 (2013), 2639-2667.
#
#            2. Detecting Multiple Influential Observations in High Dimensional Linear Regression,
#               Author(s): Junlong Zhao, Ying Zhao, Lu Niu 
#               Journal: Advanced Intelligent Computing Theories and Applications, 2015, 55-64.  
#
# Args:
#   X.original       :  the original design matrx 
#   typePerturb      :  type of perturbation 
#   beta0            :  true regression coefficient 
#   y.infl.pos       :  indices of observations that are perturbed  
#   x.infl.pos       :  indices of explanatory variables that are perturbed  
#   y.perturb        :  magnitude of perturbation on the response vector 
#   x.perturb        :  magnitude of perturbation on the covariates 
#   sigma.y          :  true square-root of noise
#
# Returns: 
#   X.tilde          :  design matrix under perturbation 
#   Y.tilde          :  response vector under perturbation 
#

data.perturb <- function(X.original, 
                         beta0,
                         typePerturb=c("original", "Zhao2013I", "Zhao2013II", "Zhao2013III",
                                                   "Zhao2015I", "Zhao2015II", "Zhao2015III",
                                                   "Zhang2022I", "Zhang2022II", "Zhang2022III","Zhang2022IV",
                                                   "binaryI",
                                                   "Poisson2023I","Poisson2023II","Poisson2023III",
                                                   "nonlinearI"), 
                         y.infl.pos, 
                         x.infl.pos, 
                         y.perturb,
                         x.perturb, 
                         sigma.y){
  
  typePerturb <- match.arg(typePerturb) 
  
  n <- nrow(X.original) 
  
  p <-ncol(X.original) 
  
  #pertubed regression coefficient;
  #Zhao2013 
  beta0.perturb           <- beta0  
  ind.zero                <- as.numeric( which(beta0 == 0, arr.ind=TRUE) )   
  beta0.perturb[ind.zero] <- y.perturb  
  
  ############################################################################## 
  #Type "original"
  if(typePerturb == "original"){
    X.tilde <- X.original;  
    Y.tilde <- X.original %*% beta0 + rnorm(n, mean=0, sd=sigma.y);  
  }
  
  ############################################################################## 
  #Type "Zhao2013I" 
  
  if(typePerturb == "Zhao2013I"){
    
    #X.tilde 
    X.tilde <- X.original; 
   
    #Y.tilde 
    if(length(y.infl.pos)==1){
      Y1 <- sum( as.vector(X.tilde[y.infl.pos,]) * beta0.perturb ) + 
            rnorm(length(y.infl.pos), mean=0, sd=sigma.y);  
      
      Y2 <- as.matrix(X.tilde[setdiff(1:n,y.infl.pos),]) %*% beta0 + 
            rnorm(length(setdiff(1:n,y.infl.pos)), mean=0, sd=sigma.y);
      
      Y.tilde <- c(Y1,Y2); 	 
    }else{
      Y1 <- as.matrix(X.tilde[y.infl.pos,]) %*% beta0.perturb + 
            rnorm(length(y.infl.pos), mean=0, sd=sigma.y);
      
      Y2 <- as.matrix(X.tilde[setdiff(1:n,y.infl.pos),]) %*% beta0 + 
            rnorm(length(setdiff(1:n,y.infl.pos)), mean=0, sd=sigma.y);
      
      Y.tilde <- c(Y1,Y2); 	 
    }
  }
  
  ############################################################################## 
  #Type "Zhao2013II"  
  
  if(typePerturb == "Zhao2013II"){
   
    #X.tilde
    X.tilde <- X.original; 
    X.tilde[y.infl.pos, x.infl.pos] <- X.original[y.infl.pos, x.infl.pos] + 30*x.perturb;   
    
    #Y.tilde
    Y.tilde <- X.original %*% beta0 + rnorm(n, mean=0, sd=sigma.y);   
  }
  
  ############################################################################## 
  #Type "Zhao2013III" 
  
  if(typePerturb == "Zhao2013III"){
    
    #X.tilde
    X.tilde <- X.original; 
    X.tilde[y.infl.pos, x.infl.pos] <- X.original[y.infl.pos, x.infl.pos] + 30*x.perturb;   
    
    #Y.tilde 
    if(length(case.perturb.ind)==1){
      Y1 <- sum( as.vector(X.tilde[y.infl.pos,]) * beta0.perturb ) + 
            rnorm(length(y.infl.pos), mean=0, sd=sigma.y); 
      
      Y2 <- as.matrix(X.tilde[setdiff(1:n,y.infl.pos),]) %*% beta0 + 
            rnorm(length(setdiff(1:n,y.infl.pos)), mean=0, sd=sigma.y);
      
      Y.tilde <- c(Y1,Y2); 	 
    }else{
      Y1 <- as.matrix(X.tilde[y.infl.pos,]) %*% beta0.perturb + 
            rnorm(length(y.infl.pos), mean=0, sd=sigma.y);
      
      Y2 <- as.matrix(X.tilde[setdiff(1:n,y.infl.pos),]) %*% beta0 + 
            rnorm(length(setdiff(1:n,y.infl.pos)), mean=0, sd=sigma.y);
      
      Y.tilde <- c(Y1,Y2); 	 
    }
  
  }
  
  ############################################################################## 
  #Type "Zhao2015I"
  
  if(typePerturb == "Zhao2015I"){
    
    #X.tilde 
    X.tilde <- X.original 
    
    #Y.tilde 
    Y.tmp <- as.matrix(X.original) %*% beta0 + rnorm(n, mean=0, sd=sigma.y)
    
    y.pos.max <- which.max(Y.tmp)
    
    Y1 <- Y.tmp[y.pos.max] + rnorm(length(y.infl.pos), mean=0, sd=sigma.y) + y.perturb 
    Y2 <- Y.tmp[-y.infl.pos] 
    
    Y.tilde <- c(Y1,Y2)  
  }
  
  ############################################################################## 
  #Type "Zhao2015II"
  
  if(typePerturb == "Zhao2015II"){
    
    Y.tmp <- as.matrix(X.original) %*% beta0 + rnorm(n, mean=0, sd=sigma.y)
    
    y.pos.max <- which.max(Y.tmp) 
    
    #X.tilde
    X.tilde <- X.original; 
    X.tilde[y.infl.pos, ] <- t(replicate(length(y.infl.pos), X.original[y.pos.max, ]));
    X.tilde[y.infl.pos, x.infl.pos] <- X.tilde[y.infl.pos, x.infl.pos] + 0.5*x.perturb
    
    #Y.tilde 
    Y1 <- X.tilde[y.infl.pos, ] %*% beta0 + rnorm(length(y.infl.pos), mean=0, sd=sigma.y)
    Y2 <- Y.tmp[-y.infl.pos] 
    
    Y.tilde <- c(Y1,Y2); 
  }
  
  ############################################################################## 
  #Type "Zhao2015III"
  
  if(typePerturb == "Zhao2015III"){
    
    Y.tmp <- as.matrix(X.original) %*% beta0 + rnorm(n, mean=0, sd=sigma.y)
    
    y.pos.max <- which.max(Y.tmp) 
    
    #X.tilde
    X.tilde <- X.original; 
    X.tilde[y.infl.pos, ] <- t(replicate(length(y.infl.pos), X.original[y.pos.max, ]));
    X.tilde[y.infl.pos, x.infl.pos] <- X.tilde[y.infl.pos, x.infl.pos] + 0.5*x.perturb
    
    #Y.tilde 
    Y1 <- X.tilde[y.infl.pos, ] %*% beta0 + rnorm(length(y.infl.pos), mean=0, sd=sigma.y) + y.perturb 
    Y2 <- Y.tmp[-y.infl.pos] 
    
    Y.tilde <- c(Y1,Y2); 
  }
  
  ############################################################################## 
  #Type "Zhang2022I"
  
  if(typePerturb == "Zhang2022I"){
    
    #X.tilde 
    X.tilde <- X.original; 
    
    #Y.tilde 
    Y.tmp <- as.matrix(X.original) %*% beta0 + rnorm(n, mean=0, sd=sigma.y)
    
    Y1 <- Y.tmp[y.infl.pos] + rnorm(length(y.infl.pos), mean=0, sd=sigma.y) + y.perturb;
    Y2 <- Y.tmp[-y.infl.pos];
    
    Y.tilde <- c(Y1,Y2);  
  }
  
  ############################################################################## 
  #Type "Zhang2022II"
  
  if(typePerturb == "Zhang2022II"){
    
    #X.tilde 
    X.tilde <- X.original  
    X.tilde[y.infl.pos, x.infl.pos] <- X.original[y.infl.pos, x.infl.pos] + x.perturb   
    
    #Y.tilde 
    Y.tilde <- X.original %*% beta0 + rnorm(n, mean=0, sd=sigma.y)  
    
  }
  
  ############################################################################## 
  #Type "Zhang2022III"
  
  if(typePerturb == "Zhang2022III"){
    
    #X.tilde 
    X.tilde <- X.original; 
    X.tilde[y.infl.pos, x.infl.pos] <- X.original[y.infl.pos, x.infl.pos] + x.perturb;  
    
    #Y.tilde 
    Y.tmp <- as.matrix(X.tilde) %*% beta0 + rnorm(n, mean=0, sd=sigma.y)
    
    Y1 <- Y.tmp[y.infl.pos] + rnorm(length(y.infl.pos), mean=0, sd=sigma.y) + y.perturb;
    Y2 <- Y.tmp[-y.infl.pos];
    
    Y.tilde <- c(Y1,Y2);   
    
  }
  
  ############################################################################## 
  #Type "Zhang2022IV"
  
  if(typePerturb == "Zhang2022IV"){
    
    beta0.clean <- rep(0,p) 
    beta0.clean[1] <- 10
    beta0.clean[2] <- 1
    
    beta0.perturb <- rep(0,p)
    beta0.perturb[5] <- 50
    
    #X.tilde 
    X.tilde <- X.original; 
    
    #Y.tilde 
    if(length(y.infl.pos)==1){
      Y1 <- sum( as.vector(X.tilde[y.infl.pos,]) * beta0.perturb ) + 
        rnorm(length(y.infl.pos), mean=0, sd=sigma.y);  
      
      Y2 <- as.matrix(X.tilde[setdiff(1:n,y.infl.pos),]) %*% beta0.clean + 
        rnorm(length(setdiff(1:n,y.infl.pos)), mean=0, sd=sigma.y);
      
      Y.tilde <- c(Y1,Y2); 	 
    }else{
      Y1 <- as.matrix(X.tilde[y.infl.pos,]) %*% beta0.perturb + 
        rnorm(length(y.infl.pos), mean=0, sd=sigma.y);
      
      Y2 <- as.matrix(X.tilde[setdiff(1:n,y.infl.pos),]) %*% beta0.clean + 
        rnorm(length(setdiff(1:n,y.infl.pos)), mean=0, sd=sigma.y);
      
      Y.tilde <- c(Y1,Y2); 	 
    }
  }
  
  ############################################################################## 
  #Type "binaryI"
  
  if(typePerturb=="binaryI"){
    
     #X.tilde 
     X.tilde <- X.original 
     
     #############################################################################################
     #Y.tilde 1
     beta0.infl <- rep(0,p)
     beta0.clean[1] <- -1
     beta0.clean[2] <- -1
     beta0.clean[3] <- -1
     
     beta0.clean <- rep(0, p)
     beta0.clean[4] <- 20
     beta0.clean[5] <- 20
     beta0.clean[6] <- 20

     Z.infl  <- as.matrix(X.tilde) %*% beta0.infl
     Z.clean <- as.matrix(X.tilde) %*% beta0.clean
     
     prob.infl <- exp(Z.infl[y.infl.pos]) / ( 1 + exp(Z.infl[y.infl.pos]))  
     
     prob.clean <- exp(Z.clean[setdiff(1:n,y.infl.pos)]) / ( 1 + exp(Z.clean[setdiff(1:n,y.infl.pos)]))    
     
     Y1 <- rbinom(length(y.infl.pos), size=1, prob=prob.infl)
     
     Y2 <- rbinom(n-length(y.infl.pos), size=1, prob=prob.clean)
     
     Y.tilde <- c(Y1,Y2)
     
     #############################################################################################
     #Y.tilde 2
     Z.tmp <-  as.matrix(X.tilde) %*% beta0 
     
     Z.pos.min <- which.min(Z.tmp)
     
     prob.infl <- ( exp(Z.tmp[Z.pos.min]) / ( 1 + exp(Z.tmp[Z.pos.min])) ) 
     
     prob.clean <- exp(Z.tmp[setdiff(1:n,y.infl.pos)]) / ( 1 + exp(Z.tmp[setdiff(1:n,y.infl.pos)]))    
     
     Y1 <- rbinom(length(y.infl.pos), size=1, prob=prob.infl)
     
     Y2 <- rbinom(n-length(y.infl.pos), size=1, prob=prob.clean)
     
     Y.tilde <- c(Y1,Y2)  
     
     #############################################################################################
    
     Xy.tilde <- as.data.frame(cbind(X.tilde, Y.tilde))
     names(Xy.tilde)<-c(paste("X",1:p,sep=""),"Y")
     
     #############################################################################################
     fit1 <- stepFlexmix(cbind(Y, 1-Y) ~ X, data = Xy.tilde, k=2, nrep=5, model = FLXMRglm(family = "binomial"))
     a1 <- posterior(fit1)[,1]
     a2 <- posterior(fit1)[,2]
     which(a1 >= a2)
     
     fit2 <- initFlexmix(cbind(Y, 1-Y) ~ X, k = 2, nrep = 5, data = Xy.tilde, model = FLXMRglm(family = "binomial"))
     a1 <- posterior(fit2)[,1]
     a2 <- posterior(fit2)[,2]
     which(a1 >= a2)
     
     fit3 <- logisregmixEM(y=Y.tilde, x=X.tilde, lambda=c(0.5,0.5), k=2, verb = TRUE, epsilon = 1e-01)
     a1 <- fit3$posterior[1,]
     a2 <- fit3$posterior[2,]
     which(a1 >= a2)
     
     
     a1 <- posterior(fit1)[,1]
     a2 <- posterior(fit1)[,2]
     
     which(a1 >= a2)
     
     a <- FLXMCmvbinary(formula = Y.tilde.mat ~ ., truncated = FALSE)
     
     ex2 <- flexmix(cbind(Y, 1-Y) ~ X, data = Xy.tilde, k = 2, model = FLXMRglm(cbind(Y, 1-Y) ~ ., family = "binomial"))

    
  }
  
  ############################################################################## 
  #Type "Poisson2023I"
  
  if(typePerturb=="Poisson2023I"){
    
    #true coefficient 
    #beta0 <- rep(0,p)
    #beta0[1:3] <- c(1,1,1)
     
    lambda <- as.matrix(X.original) %*% beta0
    
    Y.tmp <- rpois(n, lambda=exp(lambda))
    
    Y.max <- max(Y.tmp)
    
    #X.tilde 
    X.tilde <- X.original
     
    #Y.tilde 
    Y1 <- rep(Y.max,length(y.infl.pos)) + y.perturb 
    
    Y2 <- Y.tmp[-y.infl.pos]
  
    Y.tilde <- as.numeric(c(Y1,Y2)) 

  }
  
  ############################################################################## 
  #Type "Poisson2023II"
  
  if(typePerturb=="Poisson2023II"){
    
    #true coefficient 
    #beta0 <- rep(0,p)
    #beta0[1:3] <- c(1,1,1)
    
    lambda <- as.matrix(X.original) %*% beta0
    
    #X.tilde 
    X.tilde <- X.original
    X.tilde[y.infl.pos, x.infl.pos] <- X.original[y.infl.pos, x.infl.pos] + x.perturb 
    
    #Y.tilde
    Y.tilde <- rpois(n, exp(lambda)) 
    
  }
  
  ############################################################################## 
  #Type "Poisson2023III"
  
  if(typePerturb=="Poisson2023III"){
    
    #true coefficient 
    #beta0 <- rep(0,p)
    #beta0[1:3] <- c(1,1,1)
    
    X.original <- as.matrix(X.original)
    
    lambda <- as.matrix(X.original) %*% beta0
    
    Y.tmp <- rpois(n, lambda=exp(lambda))
    
    Y.max <- max(Y.tmp)
    
    y.pos.max <- which.max(Y.tmp)
    
    #X.tilde 
    X.tilde <- X.original  
    X.tilde[y.infl.pos, ] <- t(replicate(length(y.infl.pos), X.original[y.pos.max, ])) 
    X.tilde[y.infl.pos, x.infl.pos] <- X.tilde[y.infl.pos, x.infl.pos] + x.perturb
    
    #Y.tilde 
    Y1 <- rep(Y.max,length(y.infl.pos)) + y.perturb 
    
    Y2 <- Y.tmp[-y.infl.pos]
    
    Y.tilde <- as.numeric(c(Y1,Y2))
    
  }
    
  ##############################################################################
  
  returnList <- list("X.tilde" = X.tilde,
                     "Y.tilde" = Y.tilde)   
  
  return(returnList) 	
  
}